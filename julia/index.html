<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style type="text/css">
    canvas {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        right: 0;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
    }
</style>
<title>julia</title>

<!-- Based on code snippets from https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/By_example/Hello_GLSL -->
<script>function main(evt) {

let gl;
let canvas;
let program;
let buffer;
let clientX = 0;
let clientY = 0;

let iResolution;
let iTime;
let iJulia;
let iCursorPos;

let startTime = Date.now() / 1000;
let julia = false;
let juliaF = 1.0;
let lastFrameTime = performance.now() / 1000;
const dpr = devicePixelRatio;

{
    setupWebGL();
    frame();
    canvas = document.querySelector('canvas');
    canvas.addEventListener('mousemove', (e) => { clientX=e.clientX * dpr; clientY=e.clientY * dpr; });
    document.addEventListener('mousedown', () => julia = true);
    document.addEventListener('mouseup', () => julia = false);
    canvas.addEventListener('touchstart', () => julia = true);
    canvas.addEventListener('touchend', e => { if (!e.touches.length) { julia = false } });
    canvas.addEventListener('touchmove', e => { const touch = e.touches[0]; if (!touch) { return; } clientX = touch.clientX * dpr; clientY = touch.clientY * dpr; });
    window.addEventListener('resize', handleResize);

    canvas.addEventListener('touchstart', () => canvas.requestFullscreen());
}

function easeInOutCubic(t) {
    return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1;
}

function frame() {
    if (gl) {
        let now = performance.now() / 1000;
        gl.uniform1f(iTime, Date.now() / 1000 - startTime);
        gl.uniform2f(iCursorPos, clientX, clientY);
        juliaF += (julia ? 1 : -1) * (now-lastFrameTime);
        juliaF = Math.min(1, Math.max(0, juliaF))
        gl.uniform1f(iJulia, easeInOutCubic(juliaF));
        gl.uniform2f(iResolution, canvas.width, canvas.height);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        lastFrameTime = now;
    }

    requestAnimationFrame(frame);
}

function cleanup() {
    if (gl) {
        gl.useProgram(null);
        if (buffer) {
            gl.deleteBuffer(buffer);
        }
        if (program) {
            gl.deleteProgram(program);
        }
    }
    gl = null;
}

function handleResize() {
    if (!gl || !canvas) {
        return;
    }
    canvas = document.querySelector("canvas");
    canvas.width = canvas.clientWidth * dpr;
    canvas.height = canvas.clientHeight * dpr;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
}

function setupWebGL () {
    /* getRenderingContext */
    canvas = document.querySelector("canvas");
    gl = canvas.getContext("webgl");
    handleResize();
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    let vertexSource = document.querySelector("#vertex-shader").innerHTML;
    let vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);
    console.log("vertex shader compilation\n" + gl.getShaderInfoLog(vertexShader));
    
    let fragmentSource = document.querySelector("#fragment-shader").innerHTML
    let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    console.log("fragment shader compilation\n" + gl.getShaderInfoLog(fragmentShader));
    
    program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.detachShader(program, vertexShader);
    gl.detachShader(program, fragmentShader);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        let linkErrLog = gl.getProgramInfoLog(program);
        console.log("link error log\n" + linkErrLog);
        return;
    }

    /* initializeAttributes */
    gl.enableVertexAttribArray(0);
    let buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, -1, -1, 1, 1, 1, 1, -1, -1, 1, -1, -1]), gl.STATIC_DRAW);

    gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);
    let position_attrib_location = gl.getAttribLocation(program, "aPos");

    gl.enableVertexAttribArray(position_attrib_location);

    gl.vertexAttribPointer(position_attrib_location, 2, gl.FLOAT, false, 0, 0);

    gl.useProgram(program);
    
    iResolution = gl.getUniformLocation(program, "iResolution");
    iCursorPos  = gl.getUniformLocation(program, "iCursorPos");
    iTime       = gl.getUniformLocation(program, "iTime");
    iJulia       = gl.getUniformLocation(program, "iJulia");
    
}

}
setTimeout(main, 100);

</script>

<script type="x-shader/x-vertex" id="vertex-shader">
    #version 100
    attribute vec2 aPos;

    void main() {
        gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);

        gl_PointSize = 64.0;
    }
</script>
<script type="x-shader/x-fragment" id="fragment-shader">
    #version 100
    precision highp float;
    #define initZoom 0.2
    #define complexSquare(z) vec2(z.x*z.x-z.y*z.y, 2.*z.x*z.y)
    #define AA 1.

    uniform vec2 iResolution;
    uniform vec2 iCursorPos;
    uniform float iTime;
    uniform float iJulia;

    void main()
    {
        vec2 middleCoord = gl_FragCoord.xy - .5*iResolution.xy;
        vec2 uv = middleCoord / max(iResolution.x, iResolution.y);
        vec2 middleCursor = iCursorPos - .5*iResolution.xy;
        vec2 cursorUv = middleCursor / max(iResolution.x, iResolution.y);
        float zoom = initZoom;// * pow(1.1, 60.*(1.-cos(iTime/10.)));
        cursorUv /= zoom;
        uv /= zoom;
        float pixelSize = 1. / zoom / max(iResolution.x, iResolution.y);
        //uv += vec2(-.549545157957,-.626413507396);
        //uv += vec2(-.24619, .75408);
        uv += vec2(-0.75, 0.0) * (1.0 - iJulia);
        cursorUv += vec2(-0.75, 0.0);

        
        vec3 fraccol = vec3(0.);
        for (float aaxn = 0.; aaxn < AA; ++aaxn) {
            for (float aayn = 0.; aayn < AA; ++aayn) {
                float iter;
                vec3 outcol = vec3(0.);
                vec2 aauv = uv + vec2(aaxn * pixelSize / AA, aayn * pixelSize / AA);
                vec2 add = iJulia * cursorUv + (1.0 - iJulia) * aauv;
                vec2 z = aauv;
                for (float i = 0.; i < 250.; ++i) {
                    iter=i;
                    vec2 tmp = complexSquare(z) + add;
                    z = complexSquare(tmp) + add; // + vec2(0.004988, -0.824560);
                    if (length(z) > 20.) { break; }
                }
                float contained = 1.-smoothstep(9.99, 10., length(z));
                outcol.b += contained;
                outcol += abs(fract(iter / 25. + vec3(0,1,2)/3. + .1*iTime)-.5)*2.;
                fraccol += outcol*(1.-contained);
            }
        }
         

        gl_FragColor = vec4(fraccol/AA/AA,1.0);
    }
</script>
<canvas>Your browser does not seem to support  HTML5 canvas.</canvas>
